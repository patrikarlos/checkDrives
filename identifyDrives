#!/usr/bin/env bash
set -euo pipefail

# Usage: ./identifyDrives [models_file]
# Default models file: /etc/default/checkDrives.models
# Set DEBUG=1 in environment to enable debug output, e.g. DEBUG=1 

MODELS_FILE="/etc/default/checkDrives.models"
CONFIG_FILE="/etc/default/checkDrives.cfg"
myVERSION="0.2.1"

debug=${DEBUG:-0}

usage() {
    cat <<EOF
Usage: $0 [-m MODELS] [-M ] [-V]
  -m MODELS Path to models file (default: $MODELS_FILE)
  -c CONFIG Update CONFIG
  -M        Build Data suitable for config file ONLY
  -V        Show version
EOF
}



show_version() {
    echo "$0 version $myVERSION"
}

show_data() {
    echo "$0 version $myVERSION"
    echo "MODELS: $MODELS_FILE"
    echo "MODELS: $CONFIG_FILE"
    echo "DEBUG: $debug"
}

log_debug() {
    if [[ "$debug" -ne 0 ]]; then
        printf 'DEBUG: %s\n' "$*" >&2
    fi
}

BUILDMODEL=0
UPDATECONFIG=0


# Parse flags first
while getopts ":c:MVhd" opt; do
  case "$opt" in
      m) MODELS_FILE="$OPTARG"; ;;
      c) CONFIG_FILE="$OPTARG"; UPDATECONFIG=1; BUILDMODEL=1; ;;
      M) BUILDMODEL=1; ;;
      V) show_version; exit 0 ;;
      h) usage; exit 0 ;;
      d) show_data; exit 0 ;; 
      \?) echo "Invalid option: -$OPTARG"; usage; exit 2 ;;
      :)  echo "Option -$OPTARG requires an argument"; usage; exit 2 ;;
  esac
done



# --- read block devices (only TYPE="disk" and ROTA="0") ---
log_debug "Gathering block devices with lsblk (TYPE=disk, ROTA=0)..."
lsblk_data="$(lsblk -dn -o NAME,MODEL,TYPE,ROTA -P | grep 'TYPE=\"disk\"' | grep 'ROTA=\"0\"' || true)"
if [[ -z "$lsblk_data" ]]; then
    echo "No non-rotational disk devices found (ROTA=0)." >&2
fi
log_debug "Raw lsblk data:"
while IFS= read -r L; do log_debug "  $L"; done <<< "$lsblk_data"

# --- parse devices into array of "NAME|MODEL" ---
devices=()
while IFS= read -r line; do
    # Extract NAME and MODEL from KEY="VALUE" pairs
    NAME="$(printf '%s\n' "$line" | sed -n 's/.*NAME="\([^"]*\)".*/\1/p')"
    MODEL="$(printf '%s\n' "$line" | sed -n 's/.*MODEL="\([^"]*\)".*/\1/p' || true)"
    # MODEL can be empty; keep it as empty string but preserve both fields
    devices+=( "${NAME}|${MODEL}" )
    log_debug "Parsed device: NAME='${NAME}' MODEL='${MODEL}'"
done <<< "$lsblk_data"

# --- read models file ---
if [[ ! -f "$MODELS_FILE" ]]; then
    echo "Models file not found: $MODELS_FILE" >&2
    exit 2
fi

models=()
while IFS= read -r m || [[ -n "$m" ]]; do
    # Trim whitespace
    m_trimmed="$(printf '%s' "$m" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    # Skip blank lines and comments
    if [[ -z "$m_trimmed" ]] || [[ "$m_trimmed" == \#* ]]; then
        continue
    fi
    models+=( "$m_trimmed" )
done < "$MODELS_FILE"

log_debug "Loaded models (count=${#models[@]}):"
for m in "${models[@]}"; do log_debug "  [$m]"; done

# --- matching ---
# We'll track:
#  - matched_by_model: associative array counting matches per model
#  - matches_list: lines "model|NAME|/dev/NAME|device_model"
#  - device_matched: whether each device had at least one match
declare -A matched_by_model
matches_list=()
device_unmatched_list=()

for dev in "${devices[@]}"; do
    NAME="${dev%%|*}"
    MODEL="${dev#*|}"        # may be empty string
    dev_display="${MODEL}"
    if [[ -z "$dev_display" ]]; then
        dev_display="${NAME}"
    fi

    log_debug "Evaluating device /dev/${NAME} with model display '${dev_display}'"

    matched_any=0
    for model in "${models[@]}"; do
        # case-insensitive substring test: is model contained in device MODEL?
        # both lowercased
        # If device MODEL is empty, we will NOT match (unless model equals NAME)
        model_lc="$(printf '%s' "$model" | tr '[:upper:]' '[:lower:]')"
        dev_model_lc="$(printf '%s' "$MODEL" | tr '[:upper:]' '[:lower:]')"

        if [[ -n "$dev_model_lc" && "$dev_model_lc" == *"$model_lc"* ]]; then
            # matched
            matched_any=1
            matched_by_model["$model"]=$(( ${matched_by_model["$model"]:-0} + 1 ))
            # save a structured entry: model|NAME|/dev/NAME|device_MODEL (device_MODEL may be blank)
            matches_list+=( "$model|$NAME|/dev/$NAME|$MODEL" )
            log_debug "Device /dev/${NAME} MATCHES model '$model' (device MODEL='$MODEL')"
            # do NOT break: allow multiple models matching same device in case of overlaps
        else
            log_debug "Device /dev/${NAME} does NOT match model '$model' (test: device '${dev_model_lc}' contains '${model_lc}')"
        fi
    done

    if [[ "$matched_any" -eq 0 ]]; then
        # device not matched by any model
        device_unmatched_list+=( "$dev_display|$NAME" )
        log_debug "Device /dev/${NAME} had NO matches (recorded as unmatched)."
    fi
done

# --- models not found on any device ---
models_not_found=()
for model in "${models[@]}"; do
    if [[ -z "${matched_by_model["$model"]:-}" ]]; then
        models_not_found+=( "$model" )
    fi
done

# --- Output the report ---

if [[ "$BUILDMODEL" -eq 0 ]]; then


    echo
    echo "======================================"
    echo " MATCH REPORT"
    echo "======================================"
    echo

    # Matched list header
    echo "Matched"
    echo "-------"
    if [[ ${#matches_list[@]} -eq 0 ]]; then
	echo "  (none)"
    else
	# Print unique matched entries grouped by model; but user asked "model and device name printed" for matched
	# We'll print each match line: "<Model> /dev/<NAME>"
	# If the model in matches entry is empty (shouldn't happen because models come from file), we skip printing empty.
	# Keep order: as discovered.
	for entry in "${matches_list[@]}"; do
            IFS='|' read -r m name devpath devmodel <<< "$entry"
            # For matched we print: "<m> <devpath>" and optionally show device model in parentheses if different
            if [[ -n "$devmodel" ]]; then
		printf '%s | %s\n' "$devpath" "$m" 
            else
		# no device MODEL, print the NAME instead
		printf '%s | %s\n' "$devpath" "$m" 
            fi
	done
    fi
    echo

    # Unmatched list header
    echo "Unmatched"
    echo "---------"
    if [[ ${#device_unmatched_list[@]} -eq 0 ]]; then
	echo "(none)"
    else
	# Print each unmatched device as: "<device_MODEL_or_NAME> /dev/<NAME>"
	for entry in "${device_unmatched_list[@]}"; do
            IFS='|' read -r dev_display name <<< "$entry"
            printf '/dev/%s | %s \n' "$name" "$dev_display" 
	done
    fi
    echo

    echo
    echo "Devices scanned: ${#devices[@]}"
    echo "Matches found: ${#matches_list[@]}"
    echo "Done."
    
else

    outData='DEVICES=(\n'
    if [[ ${#matches_list[@]} -eq 0 ]]; then
	outData=$'DEVICES=(\n(none)\n'
    else
	for entry in "${matches_list[@]}"; do
            IFS='|' read -r m name devpath devmodel <<< "$entry"
            # For matched we print: "<m> <devpath>" and optionally show device model in parentheses if different
	    outData+="   \"${devpath}\"\n"
	done
	outData+=')'
    fi



    if [[ "$UPDATECONFIG" -eq 1 ]]; then
	echo "--Updating $CONFIG_FILE--";


	# Sanity checks
	if [[ -z "$CONFIG_FILE" ]]; then
            echo "ERROR: CONFIG_FILE is empty. Aborting." >&2
            exit 1
	fi
	if [[ ! -f "$CONFIG_FILE" ]]; then
            echo "ERROR: CONFIG_FILE '$CONFIG_FILE' does not exist. Aborting." >&2
            exit 1
	fi
	if [[ -z "$outData" ]]; then
            echo "ERROR: outData is empty. Aborting." >&2
            exit 1
	fi

	# Normalize trailing newline in outData
	[[ "${outData: -1}" != $'\n' ]] && outData+=$'\n'

	# Backup
	BACKUP="${CONFIG_FILE}.bak.$(date +%F-%H%M%S)"
	cp -a -- "$CONFIG_FILE" "$BACKUP" || {
            echo "ERROR: Failed to create backup at $BACKUP" >&2
            exit 1
	}

	
# Replace DEVICES block using awk (rename state var to avoid 'in' clash)
    tmp_cfg="$(mktemp)"
    awk -v block="$outData" '
      BEGIN { inblk=0; replaced=0 }
      # Start of DEVICES block
      /^DEVICES=\(/ {
        printf "%s", block
        inblk=1
        replaced=1
        next
      }
      # Closing line of the DEVICES block: a lone ")" (allow whitespace)
      inblk && /^[[:space:]]*\)[[:space:]]*$/ {
        inblk=0
        next
      }
      # Skip all lines inside the old DEVICES block
      inblk { next }
      # Otherwise print unchanged
      { print }
      END {
        # If no DEVICES block was found, append ours at EOF
        if (!replaced) {
          print ""
          printf "%s", block
        }
      }
    ' "$CONFIG_FILE" > "$tmp_cfg" || {
        echo "ERROR: awk replacement failed." >&2
        rm -f "$tmp_cfg"
        exit 1
    }


	# Move into place
	mv "$tmp_cfg" "$CONFIG_FILE" || {
            echo "ERROR: Failed to update $CONFIG_FILE" >&2
            exit 1
	}


	
	echo "Updated DEVICES in $CONFIG_FILE. Backup: $BACKUP"
	
    else
	echo -e "$outData"
    fi
	      
fi


# # Models not found
# echo "Models NOT found on any device:"
# if [[ ${#models_not_found[@]} -eq 0 ]]; then
#     echo "  (all models were found on at least one device)"
# else
#     for m in "${models_not_found[@]}"; do
#         printf '  - %s\n' "$m"
#     done
# fi
# echo

# # Print the regex used for each model (for debugging / transparency)
# echo "Model -> Regex used (case-insensitive substring test):"
# for m in "${models[@]}"; do
#     # Create a displayed regex: replace spaces with .*
#     disp_regex=".*${m// /.*}.*"
#     echo "  '$m' -> '$disp_regex'  (case-insensitive substring match)"
# done


